<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://Suppplier.github.io</id><title>Steadily, Constantly, Consistently</title><subtitle></subtitle> <updated>2021-12-28T18:07:40+09:00</updated> <author> <name>Bandito</name> <uri>https://Suppplier.github.io</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://Suppplier.github.io" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator> <rights> © 2021 Bandito </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>[CS] 운영체제 - 페이지 교체 알고리즘</title><link href="https://Suppplier.github.io/posts/cs_OS-Page-Replacement-Algorithm/" rel="alternate" type="text/html" title="[CS] 운영체제 - 페이지 교체 알고리즘" /><published>2021-12-28T18:04:00+09:00</published> <updated>2021-12-28T18:04:00+09:00</updated> <id>https://Suppplier.github.io/posts/cs_OS-Page-Replacement-Algorithm/</id> <content src="https://Suppplier.github.io/posts/cs_OS-Page-Replacement-Algorithm/" /> <author> <name>Bandito</name> </author> <category term="Study" /> <category term="CS" /> <summary> 페이지 교체 알고리즘 페이지 교체 알고리즘이란 운영체제는 주 기억장치보다 더 큰 용량의 프로그램을 실행하기 위해 프로그램의 일부만 주 기억장치에 적재하여 사용하는 가상 메모리 기법 을 사용한다. 요구 페이지 기법으로 프로세스가 특정 페이지를 로딩하는데, 필요한 페이지가 주 기억장치에 적재되지 않았을 시에는 이를 페이지 부재 라고 한다. 페이지 부재 시에는 페이지를 찾아 빈 프레임에 로딩해야 하는데, 만약 페이지를 올릴 빈 프레임이 없을 경우에는 기존의 프레임과 교체를 수행해야 한다. 프레임 : 물리 메모리를 일정한 크기로 나눈 블록 페이지 : 가상 메모리를 일정한 크기로 나눈 블록 이 때 사용하는 것이 페이지 교체 알고리즘 이다. 페... </summary> </entry> <entry><title>[CS] 운영체제 - 페이징 &amp; 세그멘테이션</title><link href="https://Suppplier.github.io/posts/cs_OS-Paging-&amp;-Segmentation/" rel="alternate" type="text/html" title="[CS] 운영체제 - 페이징 &amp; 세그멘테이션" /><published>2021-12-27T19:43:00+09:00</published> <updated>2021-12-27T19:43:00+09:00</updated> <id>https://Suppplier.github.io/posts/cs_OS-Paging-&amp;-Segmentation/</id> <content src="https://Suppplier.github.io/posts/cs_OS-Paging-&amp;-Segmentation/" /> <author> <name>Bandito</name> </author> <category term="Study" /> <category term="CS" /> <summary> 페이징 &amp;amp; 세그멘테이션 가상 메모리 (Virtual Memory) 실제 메모리 크기와 상관 없이 메모리를 사용할 수 있도록 가상 메모리 주소를 사용하는 것 프로세스의 일부분만 메모리에 로드하고, 나머지는 보조기억장치(가상 메모리 공간)에 둔다. 이를 통해 실행 중인 프로세스가 가상의 공간을 참조하여, 마치 커다란 물리 메모리를 갖고 있는 것 처럼 사용할 수 있다. 가상 메모리 사용의 장점 실제 메모리 (RAM)보다 더 큰 공간 사용 가능 가상의 주소 공간을 사용하여 논리적인 연속성 제공 물리 메모리의 주소 공간을 알 필요가 없어짐 MMU를 통하여 가상 주소를 실제 메모리 주소로 변환하여 사용한다. 메... </summary> </entry> <entry><title>[CS] 운영체제 - 세마포어 &amp; 뮤텍스</title><link href="https://Suppplier.github.io/posts/cs_OS-Semaphore-&amp;-Mutex/" rel="alternate" type="text/html" title="[CS] 운영체제 - 세마포어 &amp; 뮤텍스" /><published>2021-12-26T18:02:00+09:00</published> <updated>2021-12-26T18:02:00+09:00</updated> <id>https://Suppplier.github.io/posts/cs_OS-Semaphore-&amp;-Mutex/</id> <content src="https://Suppplier.github.io/posts/cs_OS-Semaphore-&amp;-Mutex/" /> <author> <name>Bandito</name> </author> <category term="Study" /> <category term="CS" /> <summary> 세마포어 &amp;amp; 뮤텍스 세마포어(Semaphore) 와 뮤텍스(Mutex) 란 여러 프로세스나 스레드가 공유 자원에 접근하면, 임계 영역(Critical Section)이 발생할 수 있기 때문에 이를 제어하기 위한 방법이다. 즉, 병행 처리를 위한 프로세스 동기화 기법을 뜻한다. 이러한 동기화 기법에는 세마포어와 뮤텍스가 존재한다. 임계 영역(Critical Section) 프로그램에서 공유 자원을 사용하는 코드 블럭을 의미한다. 여러 프로세스가 동일 자원을 사용할 때, 이를 동시에 참조하는 경우 값이 오염될 위험이 있다. 그러므로 프로그래밍 시, 성능 향상을 위해 이러한 임계 영역을 최소화하는 설계를 할 필요성이 있다. 뮤텍스(Mutext) ... </summary> </entry> <entry><title>[CS] 운영체제 - 경쟁 상태</title><link href="https://Suppplier.github.io/posts/cs_OS-Race-Condition/" rel="alternate" type="text/html" title="[CS] 운영체제 - 경쟁 상태" /><published>2021-12-26T16:47:00+09:00</published> <updated>2021-12-26T16:47:00+09:00</updated> <id>https://Suppplier.github.io/posts/cs_OS-Race-Condition/</id> <content src="https://Suppplier.github.io/posts/cs_OS-Race-Condition/" /> <author> <name>Bandito</name> </author> <category term="Study" /> <category term="CS" /> <summary> 경쟁 상태 경쟁 상태 (Race Condition)란 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태를 뜻한다. 접근하는 순서, 프로세스의 실행 기간 등에 영향을 받기 때문에 매번 실행 결과가 달라지게 된다. 동시 접근 시 자료의 일관성을 해치는 결과가 나타날 수 있다. 경쟁 상태도 교착 상태의 종류 중 하나라고 볼 수 있다. 경쟁 상태가 일어날 수 있는 시나리오 두 프로세스 P1, P2 가 있다. 두 프로세스의 수행 시간은 동일하다. 두 프로세스의 연산은 서로 다르다.’ 두 프로세스는 동일한 공유 데이터의 값을 읽고, 각자 다른 연산을 수행하여 이를 저장한다. 경쟁 상태가 발생하는 경우 커널 작업을 수행... </summary> </entry> <entry><title>[CS] 운영체제 - 데드락</title><link href="https://Suppplier.github.io/posts/cs_OS-Deadlock/" rel="alternate" type="text/html" title="[CS] 운영체제 - 데드락" /><published>2021-12-25T15:47:00+09:00</published> <updated>2021-12-25T15:47:00+09:00</updated> <id>https://Suppplier.github.io/posts/cs_OS-Deadlock/</id> <content src="https://Suppplier.github.io/posts/cs_OS-Deadlock/" /> <author> <name>Bandito</name> </author> <category term="Study" /> <category term="CS" /> <summary> 데드락 (Deadlock) Deadlock 이란 데드락(교착상태)란, 시스템 자원에 대한 요구가 뒤엉킨 상태를 의미한다. 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황이다. 시스템적으로 한정된 자원을 여러 곳에서 사용하려 하지만, 자신이 원하는 리소스가 상대방에게 할당되어 있기 때문에 프로세스가 진행되지 못한다. 데드락이 발생할 수 있는 경우 프로세스1과 2가 자원1, 자원2 를 모두 얻어야 하는 상황이라면 t1 : 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음 t2 : 프로세스1은 자원2를 기다림 / 프로세스2가 자원1을 기다림 이 상태가 무한히 지속됨 ... </summary> </entry> </feed>
