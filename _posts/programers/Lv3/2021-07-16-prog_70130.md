---
title: "[Programmers][Javascript] 스타 수열"
author: Bandito
date: 2021-07-16 18:50:00 +0900
categories: [Study, Programmers]
tags: [Algorithm, Programmers, Javascript]
comment: true
---
 
# Programmers - 스타 수열 

***
### 문제 링크 : <https://programmers.co.kr/learn/courses/30/lessons/70130>

***

<br/>

## 문제
***

다음과 같은 것들을 정의합니다.

+ 어떤 수열 x의 [부분 수열(Subsequence)](https://en.wikipedia.org/wiki/Subsequence)이란, x의 몇몇 원소들을 제거하거나 그러지 않고 남은 원소들이 원래 순서를 유지하여 얻을 수 있는 새로운 수열을 말합니다.
    - 예를 들어, [1,3]은 [1,2,3,4,5]의 부분수열입니다. 원래 수열에서 2, 4, 5를 제거해서 얻을 수 있기 때문입니다.
+ 다음과 같은 조건을 모두 만족하는 수열 x를 스타 수열이라고 정의합니다.
    - x의 길이가 2 이상의 짝수입니다. (빈 수열은 허용되지 않습니다.)
    - x의 길이를 2n이라 할 때, 다음과 같은 n개의 집합 {x[0], x[1]}, {x[2], x[3]}, ..., {x[2n-2], x[2n-1]} 의 교집합의 원소의 개수가 1 이상입니다.
    - x[0] != x[1], x[2] != x[3], ..., x[2n-2] != x[2n-1] 입니다.
    - 예를 들어, [1,2,1,3,4,1,1,3]은 스타 수열입니다. {1,2}, {1,3}, {4,1}, {1,3} 의 교집합은 {1} 이고, 각 집합 내의 숫자들이 서로 다르기 때문입니다.

1차원 정수 배열 a가 매개변수로 주어집니다. a의 모든 부분 수열 중에서 가장 길이가 긴 스타 수열의 길이를 return 하도록 solution 함수를 완성해주세요. 이때, a의 모든 부분 수열 중에서 스타 수열이 없다면, 0을 return 해주세요.


## 제한사항

+ a의 길이는 1 이상 500,000 이하입니다.
    - a의 모든 수는 0 이상 (a의 길이) 미만입니다.

<br/>

## 입출력 예제

|a|result|
|----|----|
|[0]|0|
|[5,2,3,3,5,3]|4|
|[0,3,3,0,7,2,0,2,2,0]|8|



## 내 풀이
***

주어진 수열 a 에서 숫자를 직접 제거하는 방식은 너무 번거롭고 오랜 시간이 걸리므로 사실상 불가능하다.   

스타 수열을 만들기 위해서는 각 수열의 숫자들을 2개씩 집합으로 쪼개야 하는데, 이 집합들에는 무조건 교집합이 1개 이상 존재해야 한다. 그 말인 즉슨, 처음 주어진 a 에서 가장 많이 등장하는 숫자의 갯수 만큼 집합이 나올 수도 있다는 뜻이다.


예시 중 a = [0,3,3,0,7,2,0,2,2,0] 에서 가장 많은 숫자는 0 이고 총 4번 등장한다.  

a 에서 0 을 찾아 순서대로 [0,3], [3,0], [2,0], [2,0] 와 같은 조합을 만들 수 있고, 이를 합치면 [0,3,3,0,2,0,2,0] 이므로 8 의 값을 얻을 수 있다.   

이러면 n 번 등장하는 숫자가 있다면 여기에 2를 곱하면 되지 않을까? 싶을 수도 있지만, 예시에 바로 반례가 있다.

a = [5,2,3,3,5,3] 에서 가장 많은 숫자는 3이고, 총 3번 등장한다.
[2,3], [3,5] 까지는 만들 수 있지만 마지막 3과 조합될 수 있는 수는 없다.    
[2,3], [5,3] 과 같이 순서를 다르게 해도 최종 결과는 4일 수 밖에 없다.   

그렇다면 a 에서 가장 많이 등장하는 수를 기준으로만 구해도 정답일 수 있을까? 


a = [4,0,0,2,1,1,1,1,1,1,1,1,0,3] 에서 가장 많은 숫자는 1 이고, 총 8번 등장한다.
1 로는 [2,1], [1,0] 총 4의 길이밖에 가지지 못한다.    
하지만 0 으로는 [4,0], [0,2], [1,0] 으로 총 6의 길이를 만들 수 있다.

결론적으로는 가장 많이 등장하는 수 만 비교해서는 안된다. 하지만 등장하는 모든 수에 대해서 비교하면 너무나도 오랜 실행시간에 시간초과가 나고 말 것이다.   

때문에 지금까지 구해진 스타 수열의 길이를 max, 다음으로 비교될 숫자 i 가 등장한 횟수를 n 이라고 할 때, max 보다 n * 2 가 작다면, i 을 가지고 최대로 스타 수열을 만들어도 그 길이는 max 보다 작으므로 계산할 필요가 없다는 뜻이다. 그러므로 이런 케이스에서 그냥 continue 를 해주면 된다. 



1. a 의 길이가 1 이하라면 스타 수열을 만들 수 없다. 바로 0을 반환해준다.
2. a 배열을 순회하면서 각 숫자가 등장한 횟수를 담는 numCheck 객체를 만들어준다.
3. numCheck 객체에 담긴 값들을 sortCheck 의 [숫자, 등장횟수] 꼴로 저장하고, sort 를 통해서 등장횟수의 내림차순으로 정렬한다.
4. sortCheck 을 반복문으로 돌린다.
    1. 현재 max 보다 sortCheck[k][1](숫자의 등장횟수) * 2 가 작다면 해당 반복은 continue 로 건너뛴다.
    2. a 를 반복문으로 돌린다.
        1. a[i] 가 sortCheck[k][0] 와 같다면
            + a[i] 와 a[i - 1] 이 같지 않고 a - 1 이 dup 이 아니라면 두 수는 스타 수열의 조합이 될 수 있으므로 cnt 를 2 증가시킨다.
            + a[i] 와 a[i + 1] 이 같지 않다면 dup 에 i + 1 을 저장하고 i 를 1 증가시킨 후 cnt 를 2 증가시킨다.
            dup 은 이후 비교할 a[i] 에서 이미 조합으로 만든 수를 중복하여 사용하지 않게 하기위한 조건으로 사용된다.
            i 를 1 증가시키는 이유는 i + 1 을 이미 조합으로 만들었으므로 그 다음 숫자를 비교하기 위함이다.
    3. 현재 cnt 가 max 보다 크다면 max 에 cnt 를 저장한다.



<br/>

<script src="https://gist.github.com/Suppplier/885622bb90d3d5c5b1913899cb2bfc9d.js"></script>

<br/>


## 소감
***

문제의 풀이 방법 자체는 혼자서 찾아냈는데, 반례를 찾아내는데에 시간이 좀 오래 걸려버렸다. 몇몇 반례는 인터넷에서 찾아서 해결했다. 

