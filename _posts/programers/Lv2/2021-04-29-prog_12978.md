---
title: "[Programmers][Javascript] 배달"
author: Bandito
date: 2021-04-29 18:50:00 +0900
categories: [Study, Programmers]
tags: [Algorithm, Programmers, Javascript]
comment: true
---
 
# Programmers - 배달

***
### 문제 링크 : <https://programmers.co.kr/learn/courses/30/lessons/12978>

***

<br/>

## 문제
***

N개의 마을로 이루어진 나라가 있습니다. 이 나라의 각 마을에는 1부터 N까지의 번호가 각각 하나씩 부여되어 있습니다. 각 마을은 양방향으로 통행할 수 있는 도로로 연결되어 있는데, 서로 다른 마을 간에 이동할 때는 이 도로를 지나야 합니다. 도로를 지날 때 걸리는 시간은 도로별로 다릅니다. 현재 1번 마을에 있는 음식점에서 각 마을로 음식 배달을 하려고 합니다. 각 마을로부터 음식 주문을 받으려고 하는데, N개의 마을 중에서 K 시간 이하로 배달이 가능한 마을에서만 주문을 받으려고 합니다. 다음은 N = 5, K = 3인 경우의 예시입니다.


![cities](https://drive.google.com/uc?export=view&id=10ael5IU_fbkCoylhGuCc65JO7V5BhKDz)

<br/>

위 그림에서 1번 마을에 있는 음식점은 [1, 2, 4, 5] 번 마을까지는 3 이하의 시간에 배달할 수 있습니다. 그러나 3번 마을까지는 3시간 이내로 배달할 수 있는 경로가 없으므로 3번 마을에서는 주문을 받지 않습니다. 따라서 1번 마을에 있는 음식점이 배달 주문을 받을 수 있는 마을은 4개가 됩니다.
마을의 개수 N, 각 마을을 연결하는 도로의 정보 road, 음식 배달이 가능한 시간 K가 매개변수로 주어질 때, 음식 주문을 받을 수 있는 마을의 개수를 return 하도록 solution 함수를 완성해주세요.


## 제한사항

+ 마을의 개수 N은 1 이상 50 이하의 자연수입니다.
+ road의 길이(도로 정보의 개수)는 1 이상 2,000 이하입니다.
+ road의 각 원소는 마을을 연결하고 있는 각 도로의 정보를 나타냅니다.
+ road는 길이가 3인 배열이며, 순서대로 (a, b, c)를 나타냅니다.
    - a, b(1 ≤ a, b ≤ N, a != b)는 도로가 연결하는 두 마을의 번호이며, c(1 ≤ c ≤ 10,000, c는 자연수)는 도로를 지나는데 걸리는 시간입니다.
    - 두 마을 a, b를 연결하는 도로는 여러 개가 있을 수 있습니다.
    - 한 도로의 정보가 여러 번 중복해서 주어지지 않습니다.
+ K는 음식 배달이 가능한 시간을 나타내며, 1 이상 500,000 이하입니다.
+ 임의의 두 마을간에 항상 이동 가능한 경로가 존재합니다.
+ 1번 마을에 있는 음식점이 K 이하의 시간에 배달이 가능한 마을의 개수를 return 하면 됩니다.

<br/>

## 입출력 예제

|N|road|K|result|
|----|----|
|5|[[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]]|3|4|
|6|[[1,2,1],[1,3,2],[2,3,2],[3,4,3],[3,5,2],[3,5,3],[5,6,1]]|4|4|


## 내 풀이
***

이번 문제는 정말 많이 헤맸다. DFS 로 풀어볼려 했었는데 잘 진행되지 않았고, 이전에 강의시간에 배웠었던 "다익스트라 알고리즘" 이라는 방식으로 푸는 것이 방법이었다.   

1. 시작 지점에서 각 지점들로 갈 수 있는 거리들을 저장하되, 바로 갈 수 없는 지점은 거리를 Infinity 로 저장한다.
2. 시작 지점에서 갈 수 있는 지점 중 가장 짧은 곳으로 간 뒤, 해당 지점에서 도착할 수 있는 다른 지점의 거리를 저장한다.
3. 만약 이미 거리가 저장된 지점인데 거쳐가서 도달할 수 있는 거리가 더 짧다면 더 짧은 거리를 저장한다.



인자로 주어진 road 배열을 뜯어보면 각 도시들간의 거리를 알 수 있는데, 입출력 예제의 두 번째 예시를 보자 

![cities](https://drive.google.com/uc?export=view&id=1t_bTappT33WtCq8ayp8YP42bDVe9jWzJ)


이러한 지도가 만들어지고, 우리는 무조건 1번 마을부터 시작할 것이다.    
이에 대해 1번 마을에서 바로 도착할 수 있는 곳의 거리에 대한 표를 만든다면     

|1번|2번|3번|4번|5번|6번|
|----|----|----|----|----|----|
|0|1|2|X|X|X|

위와 같은 표가 나온다. 당장 1번 마을에서 갈 수 있는 마을은 2, 3번 마을이고 나머지 마을들은 다른 마을을 거치지 못한다면 도착할 수 없다.     

여기서 2번 마을로 나아갈 수 있고 2번 마을에서는 3번 마을로 갈 수 있지만, 1번 마을에서 3번 마을로 가는 거리 (2) 가 2번 마을을 거쳐 3번 마을로 가는 거리 (1 + 2) 가 더 기므로 거리를 변경하지 않는다.

3번 마을로 나아간다면 갈 수 있는 곳이 늘어난다.   

|1번|2번|3번|4번|5번|6번|
|----|----|----|----|----|----|
|0|1|2|2 + 3|2 + 2|X|

3번 마을을 거친다면 2, 4, 5 번 마을로 갈 수 있다.
4, 5번 마을은 3번 마을을 거쳐 갈 수 있고, 2번 마을은 거리가 더 멀어지므로 갱신할 필요가 없다.

3번을 거쳐 4번 마을로 간다면 갈 수 있는 곳이 없어서 더 이상 갱신할 필요가 없고, 5번 마을로 간다면 마지막으로 다음과 같은 로드맵이 완성된다.    

|1번|2번|3번|4번|5번|6번|
|----|----|----|----|----|----|
|0|1|2|2 + 3|2 + 2|2 + 2 + 1|

이처럼 처음 마을에서 갈 수 있는 마을로 간 후 다시 갈 수 있는 마을들 중에서 거리를 갱신한 마을을 스택에 저장한다.    

반복문을 통해 스택에 저장된 마을들을 하나씩 꺼내 도달하면서 새로 갈 수 있는 마을들을 스택에 저장하는 것을 반복하고, 스택이 텅 빌 때 까지 반복한다.

<br/>

readRoad 함수를 통해 전반적인 프로세스가 진행된다.

1. 1번 마을에서 도착할 수 있는 마을들의 거리를 저장하는 N 크기의 map 배열을 만들고 모든 거리를 Infinity 로 초기화한 뒤 0번째 자리는 거리를 0으로 한다.
2. getFirstMap 함수를 통해 인자로 주어진 road 배열을 탐색한다.
    1. road 배열을 탐색하면서 1번 마을에서 갈 수 있는 길이 저장되어있다면 이를 map 배열에 반영한다.
    2. map 배열에 값을 반영할 때 마다 해당 마을은 갈 수 있는 마을이 되므로, 이 마을의 번호와 거리를 stack 배열에 push 한다.
    3. stack 에 시작 마을과 그 위치를 의미하는 [0, 0] 또한 저장한다.
3. stack 배열을 거리가 짧은 순으로 정렬한다.
4. stack 배열이 텅 빌 때 까지 반복되는 while 문을 돌린다.
    1. stack 에서 pop 으로 가장 거리가 짧은 마을의 번호를 i 에 저장한다.
    2. road 배열을 탐색하면서 i 마을에서 갈 수 있는 마을과 거리를 탐색한다. 만약 현재 저장된 거리보다 짧은 거리로 갈 수 있다면 이를 갱신하는 compareAndChange 함수를 사용한다.
    3. 탐색이 끝나면 stack 배열을 다시 거리가 짧은 순으로 정렬한다.
5. getAnswer 함수를 통해 map 배열에서 목표 거리 K 보다 짧은 위치인 마을의 갯수를 센다.

<br/>

<script src="https://gist.github.com/Suppplier/849db05407192a92fad5751d2695d222.js"></script>

<br/>

***

#### 6월 28일 갱신

<script src="https://gist.github.com/Suppplier/073992c8bcc5c4f670a862e41891cd77.js"></script>

+ 이번에는 내 힘으로 코드를 작성할 수 있었다!

## 소감
***

다익스트라 알고리즘을 써서 푼다는 것 까지는 좋았으나, 몇 가지 테스트케이스를 통과하지 못해서 결국 다른 사람들의 코드를 참고하였다.    

처음에는 아무 생각 없이 모든 마을들을 순서대로 탐색했는데, 현재 도달할 수 있는 마을들 중 짧은 마을을 우선적으로 탐색하여 거리를 배정해야했다.    

지금은 코드에 대해 숙지했지만, 이를 다른 사람에게 설명해준다고 생각하면 조금 부족함이 느껴지는 것 같다.. 

