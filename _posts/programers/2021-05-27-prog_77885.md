---
title: "[Programmers][Javascript] 2개 이하로 다른 숫자"
author: Bandito
date: 2021-05-27 23:10:00 +0900
categories: [Study, Programmers]
tags: [Algorithm, Programmers, Javascript]
comment: true
---
 
# Programmers - 2개 이하로 다른 숫자

***
### 문제 링크 : <https://programmers.co.kr/learn/courses/30/lessons/77885>

***

<br/>

## 문제
***

양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.

x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수
예를 들어,

f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

+ 2 : 0010
+ 3 : 0011

f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

+ 7 : 0111
+ 8 : 1000
+ 9 : 1001
+ 10 : 1010
+ 11 : 1011

정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

## 제한사항

+ 1 ≤ numbers의 길이 ≤ 100,000
+ 0 ≤ numbers의 모든 수 ≤ 1015


<br/>

## 입출력 예제

|numbers|result|
|----|----|
|[2, 7]|[3, 11]|





## 내 풀이
***

2진수로 변환했을 때, 답을 찾는 방법은 두 가지로 구분할 수 있다.
 + 모든 비트가 1일 때
 + 0 인 비트가 섞여있을 때 

모든 비트가 1이라면 현재 수 보다 큰 수를 찾아야 하므로 무조건 맨 우측의 새로운 비트가 1로 변경되어야 하므로 우리가 변경할 수 있는 비트는 단 하나 뿐이다.    
모든 자리가 1 이었으므로 가장 작은 수를 만들기 위해서는 추가한 비트의 바로 오른쪽 비트를 0으로 바꿔주는 방법 뿐이다.

0 인 비트가 섞여 있다면 가장 우측에 존재하는 0 인 비트를 1로 변경한 뒤 그 다음 비트가 존재한다면 이를 0으로 바꿔준다. 0을 1로 바꿔주는 것은 현재 수보다 더 큰 값을 구하기 위해 필연적인 일이다.
 
또한 무조건 두 개의 비트를 변경할 필요가 없이 1개의 비트만 변경해도 되므로 이와 같은 해결 방법을 사용할 수 있다.   
0인 비트가 맨 우측에 있다면 하나의 변경만으로 가장 작은 수를 찾아낼 수 있고, 설령 더 왼쪽에 존재한다 하더라도 변경하는 비트의 다음 비트 값을 내림으로 구할 수 있는 수 중에서는 가장 작은 수를 구할 수 있다.    


1. toString 메서드로 숫자를 2진수로 변환한 뒤, 왼쪽에서부터 '0' 의 존재를 찾는다.
2. 0 이 존재한다면 해당 위치의 비트를 1로 바꾸고 그 다음 비트가 존재한다면 0으로 바꾼다.
3. 0이 존재하지 않는다면 가장 왼쪽에 1 비트를 추가하고 그 다음 비트를 0으로 바꾼다.
4. 10진수로 변환하여 answer 에 추가한다.


<br/>

<script src="https://gist.github.com/Suppplier/d56f6aba94756cd49d764b08ddede644.js"></script>

<br/>


## 소감
***

더 효율적인 방법이 있을 것 같지만 결국 찾아내지 못했다. 문자열을 다루는 문제들은 풀이 자체는 어느정도 해결할 수 있지만 실행시간에서 항상 손해를 보는 것 같다.


