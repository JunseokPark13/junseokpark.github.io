---
title: "[Programmers][Javascript] 방금그곡"
author: Bandito
date: 2021-04-07 20:00:00 +0900
categories: [Study, Programmers]
tags: [Algorithm, Programmers, Javascript]
comment: true
---
 
# Programmers - 방금그곡

***
### 문제 링크 : <https://programmers.co.kr/learn/courses/30/lessons/17684>

***

<br/>

## 문제
***

라디오를 자주 듣는 네오는 라디오에서 방금 나왔던 음악이 무슨 음악인지 궁금해질 때가 많다. 그럴 때 네오는 다음 포털의 '방금그곡' 서비스를 이용하곤 한다. 방금그곡에서는 TV, 라디오 등에서 나온 음악에 관해 제목 등의 정보를 제공하는 서비스이다.

네오는 자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악을 찾는다. 그런데 라디오 방송에서는 한 음악을 반복해서 재생할 때도 있어서 네오가 기억하고 있는 멜로디는 음악 끝부분과 처음 부분이 이어서 재생된 멜로디일 수도 있다. 반대로, 한 음악을 중간에 끊을 경우 원본 음악에는 네오가 기억한 멜로디가 들어있다 해도 그 곡이 네오가 들은 곡이 아닐 수도 있다. 그렇기 때문에 네오는 기억한 멜로디를 재생 시간과 제공된 악보를 직접 보면서 비교하려고 한다. 다음과 같은 가정을 할 때 네오가 찾으려는 음악의 제목을 구하여라.

1. 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.
2. 사전에서 현재 전의 색인 번호를 출력하고, 입력에서 w를 제거한다.
4. 입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다.
5. 단계 2로 돌아간다.

압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자.

|색인 번호|1|2|3|...|24|25|26|
|----|----|----|----|----|----|----|----|
|단어|A|B|C|...|X|Y|Z|

예를 들어 입력으로 KAKAO가 들어온다고 하자.

1. 현재 사전에는 KAKAO의 첫 글자 K는 등록되어 있으나, 두 번째 글자까지인 KA는 없으므로, 첫 글자 K에 해당하는 색인 번호 11을 출력하고, 다음 글자인 A를 포함한 KA를 사전에 27 번째로 등록한다.
2. 두 번째 글자 A는 사전에 있으나, 세 번째 글자까지인 AK는 사전에 없으므로, A의 색인 번호 1을 출력하고, AK를 사전에 28 번째로 등록한다.
3. 세 번째 글자에서 시작하는 KA가 사전에 있으므로, KA에 해당하는 색인 번호 27을 출력하고, 다음 글자 O를 포함한 KAO를 29 번째로 등록한다.
4. 마지막으로 처리되지 않은 글자 O에 해당하는 색인 번호 15를 출력한다.


|현재 입력(w)|다음 글자(c)|출력|사전 추가(w+c)|
|----|----|----|----|
|K|A|11|27: KA|
|A|K|1|28: AK|
|KA|O|27|29: KAO|
|O||15||

이 과정을 거쳐 다섯 글자의 문장 KAKAO가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다.

## 입력 형식

입력으로 영문 대문자로만 이뤄진 문자열 msg가 주어진다. msg의 길이는 1 글자 이상, 1000 글자 이하이다.

## 출력 형식

주어진 문자열을 압축한 후의 사전 색인 번호를 배열로 출력하라.


<br/>

## 입출력 예제

|msg|answer|
|----|----|
|KAKAO|[11, 1, 27, 15]|
|TOBEORNOTTOBEORTOBEORNOT|[20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34]|
|ABABABABABABABAB|[1, 2, 27, 29, 28, 31, 30]|


<br/>

## 내 풀이
***

1. 기본적으로 A~Z 값이 들어갈 dict 배열을 만든다. 배열 안에 반복문을 사용하여 A 부터 Z 까지의 값들을 넣어준다.
2. indexOf 함수를 사용하여 msg 에서 dict 에 있는 문자가 존재하고, 그 위치가 msg 문자열에서의 첫 위치인지를 확인한다. dict 배열의 맨 마지막 값 부터 첫 번째 값 까지 비교하는데, 이는 추후 새롭게 추가될 w 는 push 로 dict 배열에 넣을 것이기 때문이다.
3. 존재하는 값을 찾았다면 j + 1 값을 answer 배열에 넣는다. j + 1 을 넣는 이유는 문제에서 A가 저장된 위치는 1, B가 저장된 위치는 2.. 와 같은 식으로 요구하는데, 실제로 저장된 인덱스는 0 부터 시작되기 때문이다.
4. 존재하는 값은 w + 1 만큼의 부분을 잘라 dict 에 추가한다. w 의 길이는 꼭 1이라는 보장이 없으므로 msg 문자열을 0번째 인덱스부터 dict[j].length + 1 만큼 잘라서 dict에 push 한다.
5. msg 에는 이미 처리된 w 만큼의 부분을 잘라내어 다시 저장한다.
6. 이 모든 과정은 msg 의 길이가 0이 될 때 까지 반복한다.

<br/>

<script src="https://gist.github.com/Suppplier/83f47233d1f2a2dea022e03a2224a51f.js"></script>



<br/>

## 소감
***

의외로 생각했던 대로 풀려서 빠르게 해결한 문제였다. 물론 이게 효율적인 방법인지는 모르겠다.. 